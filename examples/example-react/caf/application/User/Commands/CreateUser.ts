import type { UseCase, RequestResult } from '@c.a.f/core';
import { pulse } from '@c.a.f/core';
import { ValidationRunner } from '@c.a.f/validation';
import { ZodValidator } from '@c.a.f/validation/zod';
import type { User } from '../../../domain';
import { UserService } from '../../../domain';
import { CreateUserSchema } from '../../../domain/User/user.validation';

/**
 * Custom error class to carry validation errors with field mapping
 */
export class UserValidationError extends Error {
  constructor(
    message: string,
    public readonly fieldErrors: Record<string, string> = {}
  ) {
    super(message);
    this.name = 'UserValidationError';
  }
}

export class CreateUser implements UseCase<[Omit<User, 'id'>], User> {
  private validator = new ZodValidator(CreateUserSchema);

  constructor(private userService: UserService) {}

  async execute(user: Omit<User, 'id'>): Promise<RequestResult<User>> {
    try {
      // Validate input using @c.a.f/validation
      const validationResult = await ValidationRunner.run(this.validator, user);
      
      if (!validationResult.success) {
        // Format errors as a record for field-level display
        const fieldErrors = ValidationRunner.formatErrorsAsRecord(validationResult.errors);
        
        // Create error message with field information
        // Format: "Validation failed: name: Name must be at least 2 characters; email: Invalid email format"
        const formattedErrors = validationResult.errors.map(err => {
          const path = Array.isArray(err.path) ? err.path.join('.') : err.path;
          return `${path}: ${err.message}`;
        });
        
        const error = new Error(`Validation failed: ${formattedErrors.join('; ')}`);
        // Attach field errors to error object for easier access
        (error as Error & { fieldErrors: Record<string, string> }).fieldErrors = fieldErrors;
        throw error;
      }

      // Create user with validated data (ID will be generated by repository)
      const userToCreate: User = {
        ...validationResult.data as Omit<User, 'id'>,
        id: '', // Will be generated by mock API
      };

      const createdUser = await this.userService.createUser(userToCreate);
      
      // Validate the created user
      if (!createdUser || !createdUser.id || !createdUser.name || !createdUser.email) {
        throw new Error('Invalid user data returned from service');
      }

      return {
        loading: pulse(false),
        data: pulse(createdUser),
        error: pulse(null! as Error),
      };
    } catch (error) {
      return {
        loading: pulse(false),
        data: pulse(null! as User),
        error: pulse(error as Error),
      };
    }
  }
}
